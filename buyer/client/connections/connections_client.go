// Code generated by go-swagger; DO NOT EDIT.

package connections

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new connections API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for connections API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
CreateConnectionUsingPOST creates virtual circuit in azure a w s or other cloud services

Arguably the most important API in the ECX API set, the Post Connections API creates a new Layer 2 virtual connection between two ECX ports. This connection can be from an ECX participant’s owned port to a cloud provider, another ECX participant, or to your own assets in another metro. Equinix has integrated with the APIs of some of the more common cloud providers such as AWS,Azure,Google Cloud Platform(GCP) and Oracle Bare Metal Cloud(OBMC) to make creating a connections as seamless as possible– although each of these providers has unique requirements.Please refer to the Use Cases sectionfor more details regarding connection to specific cloud providers.API developers creating a connection will be required to know several attributes of their connection including the primary and secondary port,the VLAN(C - Tag and / or S - Tag),etc.These are described more in the swagger specs on the developer portal.
*/
func (a *Client) CreateConnectionUsingPOST(params *CreateConnectionUsingPOSTParams, authInfo runtime.ClientAuthInfoWriter) (*CreateConnectionUsingPOSTOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateConnectionUsingPOSTParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createConnectionUsingPOST",
		Method:             "POST",
		PathPattern:        "/ecx/v3/l2/connections",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateConnectionUsingPOSTReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateConnectionUsingPOSTOK), nil

}

/*
DeleteConnectionUsingDELETE APIs for delete connection

Used to delete a virtual connection on ECX based on the connection id. Once a connection has been successfully deleted, billing for that connections will also be stopped.
*/
func (a *Client) DeleteConnectionUsingDELETE(params *DeleteConnectionUsingDELETEParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteConnectionUsingDELETEOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteConnectionUsingDELETEParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteConnectionUsingDELETE",
		Method:             "DELETE",
		PathPattern:        "/ecx/v3/l2/connections/{connId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConnectionUsingDELETEReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteConnectionUsingDELETEOK), nil

}

/*
GetAllBuyerConnectionsUsingGET as a buyer fetch all my connections to services profiles

The Get Connections API will retrieve all connections to a specified service profile. This API will return all connections on the ECX participant’s ports and to which service profiles (AWS/Azure or others) the connection has been made. This is useful to monitor the number of connections on existing ports and the amount of bandwidth consumed by these connections.
*/
func (a *Client) GetAllBuyerConnectionsUsingGET(params *GetAllBuyerConnectionsUsingGETParams, authInfo runtime.ClientAuthInfoWriter) (*GetAllBuyerConnectionsUsingGETOK, *GetAllBuyerConnectionsUsingGETNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAllBuyerConnectionsUsingGETParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getAllBuyerConnectionsUsingGET",
		Method:             "GET",
		PathPattern:        "/ecx/v3/l2/buyer/connections",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAllBuyerConnectionsUsingGETReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetAllBuyerConnectionsUsingGETOK:
		return value, nil, nil
	case *GetAllBuyerConnectionsUsingGETNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
GetConnectionByUUIDUsingGET fetches connection details by connection UUID

An ECX participant may wish to use an API to get specific details about an existing connection. For example, they may be interested in the allocated bandwidth on that connection in order to determine throughput options. Or they may want to know the VLAN tag on a particular connection, or even to what service profile (or cloud provider) the connection has been created.  Or they may want to know if the connection was successfully provisioned. All these details can be found by calling the Get Connections API.
*/
func (a *Client) GetConnectionByUUIDUsingGET(params *GetConnectionByUUIDUsingGETParams, authInfo runtime.ClientAuthInfoWriter) (*GetConnectionByUUIDUsingGETOK, *GetConnectionByUUIDUsingGETNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetConnectionByUUIDUsingGETParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConnectionByUuidUsingGET",
		Method:             "GET",
		PathPattern:        "/ecx/v3/l2/connections/{connId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConnectionByUUIDUsingGETReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetConnectionByUUIDUsingGETOK:
		return value, nil, nil
	case *GetConnectionByUUIDUsingGETNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PerformUserActionUsingPATCH APIs for seller to perform operations on a virtual circuit by a buyer

When an ECX participant creates a connection to a service provider (cloud provider or another ECX participant), that service provider may be required to accept (or reject) the connection – depending on if the service provider has chosen the option to accept/reject connections. The Patch Connections API can be used by that service provider to accept, reject or confirm the deletion of virtual circuit connections.
*/
func (a *Client) PerformUserActionUsingPATCH(params *PerformUserActionUsingPATCHParams, authInfo runtime.ClientAuthInfoWriter) (*PerformUserActionUsingPATCHOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPerformUserActionUsingPATCHParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "performUserActionUsingPATCH",
		Method:             "PATCH",
		PathPattern:        "/ecx/v3/l2/connections/{connId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PerformUserActionUsingPATCHReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PerformUserActionUsingPATCHOK), nil

}

/*
ValidateAuthorizationKeyUsingGET validates service key based on metrocode

This API validates a MSFT Azure service key for an ECX participant wishing to connect to Azure. The participant must first use the Azure portal to establish an ExpressRoute service and obtain a valid service key that is then used to create the connections to MS Azure from ECX. Participants may validate their service key using this API. They must also know the primary and secondary port on which the connection will be created.
*/
func (a *Client) ValidateAuthorizationKeyUsingGET(params *ValidateAuthorizationKeyUsingGETParams, authInfo runtime.ClientAuthInfoWriter) (*ValidateAuthorizationKeyUsingGETOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewValidateAuthorizationKeyUsingGETParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "validateAuthorizationKeyUsingGET",
		Method:             "GET",
		PathPattern:        "/ecx/v3/l2/connections/validateAuthorizationKey",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ValidateAuthorizationKeyUsingGETReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ValidateAuthorizationKeyUsingGETOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
