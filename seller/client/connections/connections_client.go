// Code generated by go-swagger; DO NOT EDIT.

package connections

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new connections API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for connections API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
GetSellerConnectionsUsingGET as a seller fetch all connections created on my services profiles

The Get Connections API (Seller) will retrieve all connections to a specified service profile. This API will return details regarding all connections where the specified service profile is a destination on the ECX platform. For example, as an ECX participant, you may wish to make your service available on the ECX platform for other partners or customers to connect to your services. These partners or customers will create connections to your services as a destination from their ports on the ECX (sometimes referred to as the origin of the connection). This is useful to monitor the number of connections on existing ports and the amount of bandwidth consumed by these connections.
*/
func (a *Client) GetSellerConnectionsUsingGET(params *GetSellerConnectionsUsingGETParams, authInfo runtime.ClientAuthInfoWriter) (*GetSellerConnectionsUsingGETOK, *GetSellerConnectionsUsingGETNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSellerConnectionsUsingGETParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getSellerConnectionsUsingGET",
		Method:             "GET",
		PathPattern:        "/ecx/v3/l2/seller/connections",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSellerConnectionsUsingGETReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetSellerConnectionsUsingGETOK:
		return value, nil, nil
	case *GetSellerConnectionsUsingGETNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PerformUserActionUsingPATCH APIs for seller to perform operations on a virtual circuit by a buyer

When a buyer creates a connection to a service provider (cloud provider or another ECX participant), that service provider may be required to accept (or reject) the connection ï¿½ depending on if the service provider has chosen to accept/reject connections. The Patch Connections API can be used by that service provider to accept, reject or confirm the deletion of a virtual circuit connections.
*/
func (a *Client) PerformUserActionUsingPATCH(params *PerformUserActionUsingPATCHParams, authInfo runtime.ClientAuthInfoWriter) (*PerformUserActionUsingPATCHOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPerformUserActionUsingPATCHParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "performUserActionUsingPATCH",
		Method:             "PATCH",
		PathPattern:        "/ecx/v3/l2/connections/{connId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PerformUserActionUsingPATCHReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PerformUserActionUsingPATCHOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
